# import sysimport osimport ConfigParserimport hashlibimport timeimport randomfrom shotgun_api3 import ShotgunOPERATOR_ENTITY = "CustomNonProjectEntity01"PASSWORD_LENGTH = 6LOGIN_LENGTH = 4# Authentification token lifespan in hoursLIFETIME = 12class ShotgunEngine():    """    Example usages:    -------------------------------------------------------------------    #Import/Instanciation    from zombie import shotgunengine    reload(shotgunengine)    core=shotgunengine.ShotgunEngine()    #Create an operator, result will contain created user and password    result = core.createOperator("TestOp")    if result != None:        createdUser, password = result        #Change password        if(core.changePassword("TestOp", password, "MyNicePassword")):            print "Success"        else:            print "Failure"         #Remove operator        print "Removed User ? " + str(core.removeOperator("TestOp"))    """    def __init__(self, configfile=""):        self.sg = None        self.SERVER_PATH = ''        self.SCRIPT_NAME = ''        self.SCRIPT_KEY = ''        self.PROJECTPATH_FN = ''        self.TASKPATH_FN = ''        self.TASKREF_FN = ''        self.configsplitcharacter = ';'        self.cmdtable = {}        if configfile == "":            configfile = os.path.dirname(os.path.realpath(__file__)) + "/TK_ShotgunConfig.config"        Shotgun.NO_SSL_VALIDATION = True        self._readconfigfile(configfile)        self.sg = Shotgun(self.SERVER_PATH, self.SCRIPT_NAME, self.SCRIPT_KEY)        self._fillcmdtable()        self.currentuser = None    # ---------------------------------------------------------------------------    # internal helpers    # ---------------------------------------------------------------------------    def _readconfigfile(self, configfile):        try:            f = open(configfile, 'r')            lines = f.readlines()            self.SERVER_PATH = lines[0].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.SCRIPT_NAME = lines[1].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.SCRIPT_KEY = lines[2].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.PROJECTPATH_FN = lines[3].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.TASKPATH_FN = lines[4].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.TASKREF_FN = lines[5].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")        finally:            f.close()    def _fillcmdtable(self):        self.cmdtable["printconfig"] = [self.printconfig, 0, 0, "Print configuration"]        self.cmdtable["loginUser"] = [self.loginUser, 2, 3, "No description"]        self.cmdtable["listTasks"] = [self.listTasks, 2, 3, "No description"]    def _hash(self, password):        return hashlib.md5(password).hexdigest()    def _encodeOperator(self, operatorData):        operatorData['name'] = operatorData.pop('code')        operatorData['login'] = operatorData.pop('sg_login')        operatorData['type'] = 'Operator'        if 'sg_password' in operatorData:            operatorData.pop('sg_password')    def _getCookiePath(self, inCreateContainer=True):        folderPath = os.path.join(os.environ["USERPROFILE"], "zombillenium", "shotgunEngine")        if inCreateContainer and not os.path.exists(folderPath):            os.makedirs(folderPath)        return os.path.join(folderPath, "auth.ini")    def createCookie(self, login, password):        cookiePath = self._getCookiePath()        config = ConfigParser.RawConfigParser()        config.add_section('auth')        config.set('auth', 'login', login)        config.set('auth', 'password', password)        config.set('auth', 'birth', int(time.time()))        with open(cookiePath, 'w') as f:            config.write(f)    def _removeCookie(self):        cookiePath = self._getCookiePath()        if os.path.isfile(cookiePath):            os.remove(cookiePath)    # ---------------------------------------------------------------------------    # Commands    # ---------------------------------------------------------------------------    # Login    def loginUser(self, login, password=None, silent=False, hashedPassword=None, createCookie=True):        """Log a user in shotgun. It would be either a 'real' shotgun User (HumanUser) or an Operator (Shotgun type defined in constant 'OPERATOR_ENTITY')        :param login: Required, login (string) of the user to log.        :param password: Required (or hashedPassword), password (string) of the user to log.        :param silent: Optional, logging (bool)        :param hashedPassword: Required (or password), the already hashed password (string) if user is supposed to be alredy logged (with cookie)        :param createCookie: Optional, create the cookie or not (bool)        :returns: dict of the logged user if successed (with keys ['code', 'sg_login', 'id', 'sg_user']), None otherwise.        """        if password == None:            password = hashedPassword        self.currentuser = self.sg.authenticate_human_user(login, password)        if(self.currentuser != None):            if(not silent):                print "User " + login + " authenticated successfully !"        else:            if hashedPassword == None:                hashedPassword = self._hash(password)            # Ok, let's try with an Operator            filters = [                ['sg_login', 'is', login],                [ "sg_password", "is", hashedPassword]           ]            fields = ['code', 'sg_login', 'id', 'sg_user']            self.currentuser = self.sg.find_one(OPERATOR_ENTITY, filters, fields)            if self.currentuser != None:                self.currentuser = self._encodeOperator(self.currentuser)                if(not silent):                    print "Operator " + login + " authenticated successfully !"            else:                print "Cannot authenticate user " + login        # If we logged in successfully, create the cookie        if self.currentuser != None and createCookie:            self.createCookie(login, hashedPassword)        return self.currentuser    def getLoggedUser(self):        cookiePath = self._getCookiePath()        config = ConfigParser.RawConfigParser()        config.read(cookiePath)        if not config.has_section("auth"):            return None        # If cookie is found, verify it's still up to date        birthSeconds = int(config.get("auth", "birth"))        if time.time() - birthSeconds >= LIFETIME * 3600:            self._removeCookie()            return None        return self.loginUser(config.get("auth", "login"), hashedPassword=config.get("auth", "password"), createCookie=False)    def logoutUser(self):        self._removeCookie()        self.currentuser = None        self.sg.close()    def getShotAssets(self):        pass    def listTasks(self, login, password, sg=None):        if(sg == None):            self.sg = Shotgun(self.SERVER_PATH, self.SCRIPT_NAME, self.SCRIPT_KEY)        else:            self.sg = sg        result = self.loginUser(login, password, self.sg)        if(result == None):            print "Incorrect login credentials !"            return        filters = [                ['task_assignees', 'is', result],                {                    "filter_operator": "any",                    "filters": [                        [ "sg_status_list", "is", "rdy"],                        [ "sg_status_list", "is", "ip" ]                    ]                }           ]        fields = ['content', 'step', 'entity', 'project', 'sg_status_list']        tasks = sg.find("Task", filters, fields)        print "Il y a " + str(len(tasks)) + " taches assignees a " + result["login"]        for task in tasks:            entityName = "NoEntity"            entityType = "NoType"            stepName = "NoStep"            if(task['entity'] != None):                entityName = task['entity']['name']                entityType = task['entity']['type']            if(task['step'] != None):                stepName = task['step']['name']            print (task['project']['name'] + " | ").ljust(25) + (entityType + " : ").ljust(10) + (stepName + " ").ljust(10) + (entityName + " - ").ljust(20) + task['content']    # Operators    def createOperator(self, login, password=None, superUser="Development Team", name=None):        #check if login already exists        filters = [                ['sg_login', 'is', login]           ]        fields = []        if len(login) < LOGIN_LENGTH:            print "Login too short ({0} characters minimum) !".format(LOGIN_LENGTH)            return None        if self.sg.find_one(OPERATOR_ENTITY, filters, fields) != None:            print "User with login {0} aleady exists !".format(login)            return None        if password == None:            #create random password            randStart = int(time.time() * 100.0)            password = self._hash(str(random.randint(randStart - 100, randStart + 100)))[:PASSWORD_LENGTH]        elif len(password) < PASSWORD_LENGTH:            print "Password too short ({0} characters minimum) !".format(PASSWORD_LENGTH)            return None        #verify that superUser exists and get its id        filters = [        ['name', 'is', superUser]           ]        fields = ['id']        userData = self.sg.find_one("HumanUser", filters, fields)        if userData == None:            print "Can't find superuser '{0}' !".format(superUser)            return None        if name == None:            name = login        elif len(name) < LOGIN_LENGTH:            print "Name too short ({0} characters minimum) !".format(LOGIN_LENGTH)            return None        #Ok, we're ready, create the Operator        data = {'sg_login': login,                'sg_password': self._hash(password),                'code': name,                'sg_user': userData }        result = self.sg.create(OPERATOR_ENTITY, data)        if result == None:            print "Cannot create operator !"            return None        self._encodeOperator(result)        return (result, password)    def changePassword(self, login, oldPassword, password, opId=None):        opData = {}        if opId == None:            #find the operator            filters = [                        ['sg_login', 'is', login],                        {                        "filter_operator": "any",                        "filters": [                            [ "sg_password", "is", ""],                            ['sg_password', 'is', self._hash(oldPassword)]                        ]                        }                    ]            fields = ['id']            opData = self.sg.find_one(OPERATOR_ENTITY, filters, fields)        else:            opData = {'type': OPERATOR_ENTITY, 'id': opId}        if opData != None:            data = {'sg_password': self._hash(password)}            opData = self.sg.update(OPERATOR_ENTITY, opData['id'], data)        if opData == None:            print "Cannot update operator password, login or old password incorrect !"            return False        return True    def removeOperator(self, login, opId=None):        opData = {}        if opId == None:            #find the operator            filters = [                    ['sg_login', 'is', login]               ]            fields = ['id']            opData = self.sg.find_one(OPERATOR_ENTITY, filters, fields)        else:            opData = {'type': OPERATOR_ENTITY, 'id': opId}        if opData == None:             print "Cannot remove operator '{0}', maybe it does not exists !".format(login)             return False        return self.sg.delete(OPERATOR_ENTITY, opData['id'])    # ---------------------------------------------------------------------------    # cmdLine part    # ---------------------------------------------------------------------------    def printconfig(self):        print '';        print ' *** TK ShotgunEngine Config ***';        print '-----------------------------------------';        print 'SERVER_PATH "' + self.SERVER_PATH + '"'        print 'SCRIPT_NAME "' + self.SCRIPT_NAME + '"'        print 'SCRIPT_KEY "' + self.SCRIPT_KEY + '"'        print 'PROJECTPATH_FN "' + self.PROJECTPATH_FN + '"'        print 'TASKPATH_FN "' + self.TASKPATH_FN + '"'        print 'TASKREF_FN "' + self.TASKREF_FN + '"'        print '-----------------------------------------';        print '';    def printhelp(self):        print '';        print ' *** TK ShotgunEngine Help ***';        print '-----------------------------------------';        for key in self.cmdtable:            print key + " : from " + str(self.cmdtable[key][1]) + " to " + str(self.cmdtable[key][2]) + " args (" + str(self.cmdtable[key][3]) + ")"        print '-----------------------------------------';        print '';    def _parsecmdline(self, arguments):        if len(arguments) == 0:            print "No argments given, please give at least a command name!"            self.printhelp()        else:            cmdName = arguments[0]            arguments = arguments[1:]            if cmdName in self.cmdtable:                minArgs = self.cmdtable[cmdName][1]                maxArgs = self.cmdtable[cmdName][2]                desc = self.cmdtable[cmdName][3]                if len(arguments) >= minArgs and len(arguments) <= maxArgs :                    self._runCommand(self.cmdtable[cmdName][0], arguments)                else:                    argsHint = cmdName + " : wrong number of arguments, "                    if minArgs == maxArgs :                        argsHint += str(minArgs)                    else:                        argsHint += str(minArgs) + " to " + str(maxArgs)                    argsHint += " expected (" + str(len(arguments) - 1) + " given)"                    print argsHint                    self.printhelp()            else:                print "Command \"" + cmdName + "\" dont 'exists !"                self.printhelp()    def _runCommand(self, cb, tokens):        if(len(tokens) == 0):            cb()        elif(len(tokens) == 1):            cb(tokens[0])        elif(len(tokens) == 2):            cb(tokens[0], tokens[1])        elif(len(tokens) == 3):            cb(tokens[0], tokens[1], tokens[2])