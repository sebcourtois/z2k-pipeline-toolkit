# import sysimport osimport ConfigParserimport hashlibimport timeimport randomimport sysfrom shotgun_api3 import ShotgunPROJECT_ID = 66OPERATOR_ENTITY = "CustomNonProjectEntity01"COMPANY_ENTITY = "CustomNonProjectEntity08"PASSWORD_LENGTH = 6LOGIN_LENGTH = 4SHOT_INFO = ["code", "sg_cut_in", "sg_cut_out", "sg_cut_duration", "sg_sequence"]# Authentification token lifespan in hoursLIFETIME = 12class ShotgunEngine():    """    Example usages:    -------------------------------------------------------------------    #Import/Instanciation    from zombie import shotgunengine    reload(shotgunengine)    core=shotgunengine.ShotgunEngine()    #Create an operator, result will contain created user and password    result = core.createOperator("TestOp")    if result != None:        createdUser, password = result        #Change password        if(core.changePassword("TestOp", password, "MyNicePassword")):            print "Success"        else:            print "Failure"         #Remove operator        print "Removed User ? " + str(core.removeOperator("TestOp"))    """    def __init__(self, configfile=""):        self.sg = None        self.SERVER_PATH = ''        self.SCRIPT_NAME = ''        self.SCRIPT_KEY = ''        self.PROJECTPATH_FN = ''        self.TASKPATH_FN = ''        self.TASKREF_FN = ''        self.configsplitcharacter = ';'        self.cmdtable = {}        if configfile == "":            configfile = os.path.dirname(os.path.realpath(__file__)) + "/TK_ShotgunConfig.config"        Shotgun.NO_SSL_VALIDATION = True        self._readconfigfile(configfile)        self.sg = Shotgun(self.SERVER_PATH, self.SCRIPT_NAME, self.SCRIPT_KEY)        self._fillcmdtable()        self.currentUser = None    # ---------------------------------------------------------------------------    # internal helpers    # ---------------------------------------------------------------------------    def _readconfigfile(self, configfile):        try:            f = open(configfile, 'r')            lines = f.readlines()            self.SERVER_PATH = lines[0].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.SCRIPT_NAME = lines[1].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.SCRIPT_KEY = lines[2].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.PROJECTPATH_FN = lines[3].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.TASKPATH_FN = lines[4].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.TASKREF_FN = lines[5].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")        finally:            f.close()    def _fillcmdtable(self):        self.cmdtable["printConfig"] = [self.printconfig, 0, 0, "Print configuration"]        self.cmdtable["loginUser"] = [self.loginUser, 2, 3, "No description"]        self.cmdtable["logoutUser"] = [self.logoutUser, 0, 0, "No description"]        self.cmdtable["createOperator"] = [self.createOperator, 1, 4, "No description : login, password=None, superUser='Development Team', name=None"]        self.cmdtable["removeOperator"] = [self.removeOperator, 1, 1, "No description : login"]        self.cmdtable["changePassword"] = [self.changePassword, 3, 3, "No description : login, oldPassword, password"]        self.cmdtable["getSteps"] = [self.getSteps, 0, 0, "No description"]        self.cmdtable["getShotAssets"] = [self.getShotAssets, 1, 1, "No description : shotCode"]        self.cmdtable["getSequencesInfo"] = [self.getSequencesInfo, 0, 1, "No description : sequenceCode"]                self.cmdtable["getShotInfo"] = [self.getShotInfo, 1, 1, "No description : shotCode"]        self.cmdtable["getShotsInfo"] = [self.getShotsInfo, 0, 2, "No description : shotCode, sequenceCode"]        self.cmdtable["listTasks"] = [self.listTasks, 2, 3, "No description"]    def _hash(self, password):        return hashlib.md5(password).hexdigest()    def _encodeOperator(self, operatorData):        operatorData['name'] = operatorData.pop('code')        operatorData['login'] = operatorData.pop('sg_login')        operatorData['type'] = 'Operator'        if 'sg_password' in operatorData:            operatorData.pop('sg_password')        if 'sg_company' in operatorData:            operatorData['sg_company']['type'] = "Company"        return operatorData    def _getCookiePath(self, inCreateContainer=True):        folderPath = os.path.join(os.environ["USERPROFILE"], "zombillenium", "shotgunEngine")        if inCreateContainer and not os.path.exists(folderPath):            os.makedirs(folderPath)        return os.path.join(folderPath, "auth.ini")    def _createCookie(self, login, password):        cookiePath = self._getCookiePath()        config = ConfigParser.RawConfigParser()        config.add_section('auth')        config.set('auth', 'login', login)        config.set('auth', 'password', password)        config.set('auth', 'birth', int(time.time()))        with open(cookiePath, 'w') as f:            config.write(f)    def _removeCookie(self):        cookiePath = self._getCookiePath()        if os.path.isfile(cookiePath):            os.remove(cookiePath)    # ---------------------------------------------------------------------------    # Commands    # ---------------------------------------------------------------------------    # Login    def loginUser(self, login, password=None, silent=False, hashedPassword=None, createCookie=True):        """Log a user in shotgun. It would be either a 'real' shotgun User (HumanUser) or an Operator (Shotgun type defined in constant 'OPERATOR_ENTITY')        :param login: Required, login (string) of the user to log.        :param password: Required (or hashedPassword), password (string) of the user to log.        :param silent: Optional, logging (bool)        :param hashedPassword: Required (or password), the already hashed password (string) if user is supposed to be alredy logged (with cookie)        :param createCookie: Optional, create the cookie or not (bool)        :returns: dict of the logged user if successed (with keys ['code', 'sg_login', 'id', 'sg_user']), None otherwise.        """        if password == None:            password = hashedPassword        self.currentUser = self.sg.authenticate_human_user(login, password)        if(self.currentUser != None):            if(not silent):                print "User " + login + " authenticated successfully !"        else:            if hashedPassword == None:                hashedPassword = self._hash(password)            # Ok, let's try with an Operator            filters = [                ['sg_login', 'is', login],                [ "sg_password", "is", hashedPassword]           ]            fields = ['code', 'sg_login', 'id', 'sg_user', 'sg_company', 'sg_allowedsteps', 'sg_currentstep']            self.currentUser = self.sg.find_one(OPERATOR_ENTITY, filters, fields)            if self.currentUser != None:                self.currentUser = self._encodeOperator(self.currentUser)                if(not silent):                    print "Operator " + login + " authenticated successfully !"            else:                print "Cannot authenticate user " + login        # If we logged in successfully, create the cookie        if self.currentUser != None and createCookie:            self._createCookie(login, hashedPassword)        return self.currentUser    def getLoggedUser(self):        cookiePath = self._getCookiePath()        config = ConfigParser.RawConfigParser()        config.read(cookiePath)        if not config.has_section("auth"):            return None        # If cookie is found, verify it's still up to date        birthSeconds = int(config.get("auth", "birth"))        if time.time() - birthSeconds >= LIFETIME * 3600:            self._removeCookie()            return None        return self.loginUser(config.get("auth", "login"), hashedPassword=config.get("auth", "password"), createCookie=False)    def logoutUser(self):        self._removeCookie()        self.currentUser = None        self.sg.close()    def getSteps(self):        type_steps = {}        steps = self.sg.find("Step", [], ["code", "entity_type"], [{'field_name':'list_order','direction':'asc'}])        for step in steps:            entity_type = step["entity_type"]            if entity_type in type_steps:                type_steps[entity_type].append(step['code'])            else:                type_steps[entity_type] = [step['code']]        return type_steps    def getShotAssets(self, in_sShotCode):        shotData = self.sg.find_one("Shot", [["project", "is", {"type":"Project", "id":PROJECT_ID}],["code", "is", in_sShotCode]], ["assets", "id"])        if shotData:            occs = []            if len(shotData["assets"]) > 0:                #We will return one occurence by default, if we want to track empty occurences we could use : ,["sg_occurences", "is_not", None]                 occs = self.sg.find("AssetShotConnection", [["shot", "is", {"type":"Shot", "id":shotData["id"]}]], ["sg_occurences", "asset"])                for occ in occs:                    if occ['sg_occurences'] == None:                        occ['sg_occurences'] = 1            else:                print "No assets associated to shot '{0}'".format(in_sShotCode)            return occs        else:            print "'{0}' shot not found !".format(in_sShotCode)        return None    def getShotInfo(self, in_sShotCode):        return self.sg.find_one("Shot", [["project", "is", {"type":"Project", "id":PROJECT_ID}],["code", "is", in_sShotCode]], SHOT_INFO)    def getSequencesInfo(self, in_sSequenceCode=""):        filters  = [["project", "is", {"type":"Project", "id":PROJECT_ID}]]        if in_sSequenceCode != "":            filters.append(["code", "contains", in_sSequenceCode])        return self.sg.find("Sequence", filters, ['code'])    def getShotsInfo(self, in_sShotCode="", in_sSequenceCode=""):        filters  = [["project", "is", {"type":"Project", "id":PROJECT_ID}]]        if in_sShotCode != "":            filters.append(["code", "contains", in_sShotCode])        if in_sSequenceCode != "":            seqs = self.getSequencesInfo(in_sSequenceCode)            if len(seqs) > 0:                filterOp = {                    "filter_operator": "any",                    "filters": []                    }                for seq in seqs:                    filterOp["filters"].append(['sg_sequence', 'is', {'type':'Sequence', 'id':seq['id']}])                            filters.append(filterOp)            else:                print "Can't find any sequences with pattern '{0}'".format(in_sSequenceCode)                return []        return self.sg.find("Shot", filters, SHOT_INFO)    def listTasks(self, login, password, sg=None):        if(sg == None):            self.sg = Shotgun(self.SERVER_PATH, self.SCRIPT_NAME, self.SCRIPT_KEY)        else:            self.sg = sg        result = self.loginUser(login, password, self.sg)        if(result == None):            print "Incorrect login credentials !"            return        filters = [                ['task_assignees', 'is', result],                {                    "filter_operator": "any",                    "filters": [                        [ "sg_status_list", "is", "rdy"],                        [ "sg_status_list", "is", "ip" ]                    ]                }           ]        fields = ['content', 'step', 'entity', 'project', 'sg_status_list']        tasks = sg.find("Task", filters, fields)        print "Il y a " + str(len(tasks)) + " taches assignees a " + result["login"]        for task in tasks:            entityName = "NoEntity"            entityType = "NoType"            stepName = "NoStep"            if(task['entity'] != None):                entityName = task['entity']['name']                entityType = task['entity']['type']            if(task['step'] != None):                stepName = task['step']['name']            print (task['project']['name'] + " | ").ljust(25) + (entityType + " : ").ljust(10) + (stepName + " ").ljust(10) + (entityName + " - ").ljust(20) + task['content']    # Operators    def createOperator(self, login, password=None, superUser="Development Team", name=None):        #check if login already exists        filters = [                ['sg_login', 'is', login]           ]        fields = []        if len(login) < LOGIN_LENGTH:            print "Login too short ({0} characters minimum) !".format(LOGIN_LENGTH)            return None        if self.sg.find_one(OPERATOR_ENTITY, filters, fields) != None:            print "User with login {0} aleady exists !".format(login)            return None        if password == None:            #create random password            randStart = int(time.time() * 100.0)            password = self._hash(str(random.randint(randStart - 100, randStart + 100)))[:PASSWORD_LENGTH]        elif len(password) < PASSWORD_LENGTH:            print "Password too short ({0} characters minimum) !".format(PASSWORD_LENGTH)            return None        #verify that superUser exists and get its id        filters = [        ['name', 'is', superUser]           ]        fields = ['id']        userData = self.sg.find_one("HumanUser", filters, fields)        if userData == None:            print "Can't find superuser '{0}' !".format(superUser)            return None        if name == None:            name = login        elif len(name) < LOGIN_LENGTH:            print "Name too short ({0} characters minimum) !".format(LOGIN_LENGTH)            return None        #Ok, we're ready, create the Operator        data = {'sg_login': login,                'sg_password': self._hash(password),                'code': name,                'sg_user': userData }        result = self.sg.create(OPERATOR_ENTITY, data)        if result == None:            print "Cannot create operator !"            return None        self._encodeOperator(result)        return (result, password)    def changePassword(self, login, oldPassword, password, opId=None):        opData = {}        if opId == None:            #find the operator            filters = [                        ['sg_login', 'is', login],                        {                        "filter_operator": "any",                        "filters": [                            [ "sg_password", "is", ""],                            ['sg_password', 'is', self._hash(oldPassword)]                        ]                        }                    ]            fields = ['id']            opData = self.sg.find_one(OPERATOR_ENTITY, filters, fields)        else:            opData = {'type': OPERATOR_ENTITY, 'id': opId}        if opData != None:            data = {'sg_password': self._hash(password)}            opData = self.sg.update(OPERATOR_ENTITY, opData['id'], data)        if opData == None:            print "Cannot update operator password, login or old password incorrect !"            return False        return True    def removeOperator(self, login, opId=None):        opData = {}        if opId == None:            #find the operator            filters = [                    ['sg_login', 'is', login]               ]            fields = ['id']            opData = self.sg.find_one(OPERATOR_ENTITY, filters, fields)        else:            opData = {'type': OPERATOR_ENTITY, 'id': opId}        if opData == None:             print "Cannot remove operator '{0}', maybe it does not exists !".format(login)             return False        return self.sg.delete(OPERATOR_ENTITY, opData['id'])    # ---------------------------------------------------------------------------    # cmdLine part    # ---------------------------------------------------------------------------    def printconfig(self):        print '';        print ' *** TK ShotgunEngine Config ***';        print '-----------------------------------------';        print 'SERVER_PATH "' + self.SERVER_PATH + '"'        print 'SCRIPT_NAME "' + self.SCRIPT_NAME + '"'        print 'SCRIPT_KEY "' + self.SCRIPT_KEY + '"'        print 'PROJECTPATH_FN "' + self.PROJECTPATH_FN + '"'        print 'TASKPATH_FN "' + self.TASKPATH_FN + '"'        print 'TASKREF_FN "' + self.TASKREF_FN + '"'        print '-----------------------------------------';        print '';    def printhelp(self):        print '';        print ' *** TK ShotgunEngine Help ***';        print '-----------------------------------------';        for key in self.cmdtable:            print key + " : from " + str(self.cmdtable[key][1]) + " to " + str(self.cmdtable[key][2]) + " args (" + str(self.cmdtable[key][3]) + ")"        print '-----------------------------------------';        print '';    def _parsecmdline(self, argumentsStr):        splitArgs = argumentsStr.split(" ")        arguments = []        grouping = None        for splitArg in splitArgs:            if "\"" in splitArg:                if grouping == None:                    grouping = [splitArg.replace("\"", "")]                else:                    grouping.append(splitArg.replace("\"", ""))                    arguments.append(" ".join(grouping))                    grouping=None            else:                if grouping != None:                    grouping.append(splitArg)                else:                    arguments.append(splitArg)        if grouping != None:            arguments.append(" ".join(grouping))                    self._readcmdline(arguments)    def _readcmdline(self, arguments):        if len(arguments) == 0:            print "No argments given, please give at least a command name!"            self.printhelp()        else:            cmdName = arguments[0]            arguments = arguments[1:]            if cmdName in self.cmdtable:                minArgs = self.cmdtable[cmdName][1]                maxArgs = self.cmdtable[cmdName][2]                desc = self.cmdtable[cmdName][3]                if len(arguments) >= minArgs and len(arguments) <= maxArgs :                    self._runCommand(self.cmdtable[cmdName][0], arguments)                else:                    argsHint = cmdName + " : wrong number of arguments, "                    if minArgs == maxArgs :                        argsHint += str(minArgs)                    else:                        argsHint += str(minArgs) + " to " + str(maxArgs)                    argsHint += " expected (" + str(len(arguments)) + " given)"                    print argsHint                    print "Description : {0}".format(self.cmdtable[cmdName][3])            else:                print "Command \"" + cmdName + "\" dont 'exists !"                self.printhelp()    def _runCommand(self, cb, tokens):        print cb(*tokens)if __name__ == '__main__':    core=ShotgunEngine()    if len(sys.argv) == 1:#Go into a input loop        cmdInput = ""        while True:            print ""            cmdInput = raw_input("Engine cmd >> ")            if "exit" in cmdInput.lower():                break            core._parsecmdline(cmdInput)    else:#execute command directly        core._readcmdline(sys.argv[1:])