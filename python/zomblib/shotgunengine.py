# import sysimport osimport ConfigParserimport hashlibimport timeimport randomimport sysimport webbrowserfrom shotgun_api3 import Shotgunfrom shotgun_api3.lib.httplib2 import ServerNotFoundErrorfrom pytd.gui.dialogs import confirmDialogfrom pytd.util.sysutils import toStr, inDevModefrom pytd.util.logutils import logMsgPROJECT_IDS = {"zombillenium":67,               "zombtest":67               }DEFAULT_PROJECT = 'zombillenium'OPERATOR_ENTITY = "CustomNonProjectEntity01"COMPANY_ENTITY = "CustomNonProjectEntity08"OPERATOR_FIELD = 'sg_operator'OPERATORS_FIELD = 'sg_operators'SOURCEFILE_FIELD = 'sg_source_file'PASSWORD_LENGTH = 6LOGIN_LENGTH = 4USER_INFO = ['code', 'sg_login', 'id', 'sg_user', 'sg_company', 'sg_allowedsteps', 'sg_currentstep', 'sg_password']SHOT_INFO = ["code", "sg_cut_in", "sg_cut_out", "sg_cut_duration", "sg_sequence"]SEQUENCE_INFO = ['code']ASSET_INFO = ["code", "sg_asset_type"]STEP_INFO = ["code", "entity_type", "id"]TASK_INFO = ['content', 'step', 'entity', 'project', 'sg_status_list', 'sg_status_art', OPERATORS_FIELD]VERSION_INFO = ['code', 'entity', 'sg_task']TYPE_INFO = {            'User':USER_INFO,            'Shot':SHOT_INFO,            'Sequence':SEQUENCE_INFO,            'Asset':ASSET_INFO,            'Task':TASK_INFO,            "Version":VERSION_INFO            }ASSET_SUBTYPE_FIELD = "sg_sous_type"if ASSET_SUBTYPE_FIELD != "":    ASSET_INFO.append(ASSET_SUBTYPE_FIELD)# Authentification token lifespan in hoursLIFETIME = 12def uploadVersionApart(versionId, s_inMediaPath):    import subprocess    sPython27Path = r"C:\Python27\python.exe"    sEnvSetupScript = os.environ["Z2K_LAUNCH_SCRIPT"]    sCmdScriptPath = os.path.join(sEnvSetupScript.split("launchers", 1)[0],                                  "scripts", "upload_to_shotgun.py")    sCmdArgs = [sPython27Path,                os.path.normpath(sEnvSetupScript),                "launch", "--update", "0", "--renew", "1",                sPython27Path,                sCmdScriptPath,                "Version", str(versionId),                os.path.normpath(s_inMediaPath),                "sg_uploaded_movie",                ]    if inDevMode():        print sCmdArgs    SW_MINIMIZE = 6    info = subprocess.STARTUPINFO()    info.dwFlags = subprocess.STARTF_USESHOWWINDOW    info.wShowWindow = SW_MINIMIZE    subprocess.Popen(sCmdArgs, startupinfo=info)class ShotgunEngine(object):    """    Example usages:    -------------------------------------------------------------------    #Import/Instanciation    from zomblib import shotgunengine    reload(shotgunengine)    core=shotgunengine.ShotgunEngine()    #Create an operator, result will contain created user and password    result = core.createOperator("TestOp")    if result != None:        createdUser, password = result        #Change password        if(core.changePassword("TestOp", password, "MyNicePassword")):            print "Success"        else:            print "Failure"         #Remove operator        print "Removed User ? " + str(core.removeOperator("TestOp"))    #Create a version    #core.createVersion(s_inName, s_inEntityName, s_inTaskName, s_inMediaPath=None, s_inComment="", s_inSourceFile="%ZOMB_ASSET_PATH%/Folder/File.extension")    #We have to log a user, rely on the fact we have a logged user already    if core.getLoggedUser() != None:        core.createVersion("sq6660_sh0010a_previz-v002", "sq6660_sh0010a", "previz 3D", "\\\\Diskstation\\Z2K\\01_PRODUCTION\\ANIMATIQUE\\ZB_V_12 Aout\\ZB_EDL_20150812_Decoupage\\sq6660_sh0010a_animatic.mov", s_inSourceFile="%ZOMB_ASSET_PATH%/Folder/File.extension")    else:        print "Please log in before creating a version !!"    #Show an entity in the web showInBrowser    #core.showInBrowser(d_inEntity)     core.showInBrowser(core.getAssetInfo("chr_actionnaire1_default"))    #get an entity    dico = core._getEntity('chr_actionnaire1_default', 'Asset')    #get a task (we need a task name and an entity, it can be given by a shotgun dictionary...)    #from the dictionary (see above)    core._getTask("Modeling", dico)    #from strings (we can also provide an entity name and an entity Type)    print core._getTask("Modeling", 'chr_actionnaire1_default', 'Asset')    """    def __init__(self, projectName=DEFAULT_PROJECT, configfile=""):        self.sg = None        self.SERVER_PATH = ''        self.SCRIPT_NAME = ''        self.SCRIPT_KEY = ''        self.PROJECTPATH_FN = ''        self.TASKPATH_FN = ''        self.TASKREF_FN = ''        self.configsplitcharacter = ';'        self.cmdtable = {}        self.projectName = projectName        self._getProjectId()        if configfile == "":            configfile = os.path.dirname(os.path.realpath(__file__)) + "/TK_ShotgunConfig.config"        Shotgun.NO_SSL_VALIDATION = True        self._readconfigfile(configfile)        try:            sg = Shotgun(self.SERVER_PATH, self.SCRIPT_NAME, self.SCRIPT_KEY)        except (ServerNotFoundError, IOError) as e:            print u"WARNING:", e.message        else:            self.sg = sg        self._fillcmdtable()        self.currentUser = None        self.__projectStatusList = None        self.__fieldSchemaData = {}    def _getEntity(self, s_or_d_inCodeOrInfo, s_inType='', l_outFields=None, l_customFilters=None):        #Find the entity        if isinstance(s_or_d_inCodeOrInfo, dict) and 'id' in s_or_d_inCodeOrInfo:            return s_or_d_inCodeOrInfo        if not s_inType in TYPE_INFO:            raise KeyError('{0} is not recognized as a Shotgun entity type !'.format(s_inType))        #given item is not a dict, find by name...        keyName = 'code'        if s_inType == 'Task':            keyName = 'content'        filters = [ ['project', 'is', {'type':'Project', 'id':self._getProjectId()}],                    [keyName, 'is', s_or_d_inCodeOrInfo],                ]        if l_customFilters:            filters.extend(l_customFilters)        if not l_outFields:            l_outFields = TYPE_INFO[s_inType]        return self.sg.find_one(s_inType, filters, l_outFields)    def _getTask(self, entity, sTaskName, sStepName=""):        filters = [ ['project', 'is', {'type':'Project', 'id':self._getProjectId()}],                    ['content', 'is', sTaskName],                    ['entity', 'is', entity],                    ]        if sStepName:            filters.append(["step.Step.code", "is", sStepName])        sgTaskList = self.sg.find("Task", filters, TASK_INFO)        if not sgTaskList:            return None        if len(sgTaskList) > 1:            sMsg = "More than one Task named '{}'".format(sTaskName)            if sStepName:                sMsg += " in '{}' Step".format(sStepName)            sMsg += " for Entity: {}\n    ".format(entity)            sMsg += "\n    ".join(repr(d["step"]) for d in sgTaskList)            raise ValueError(sMsg)        return sgTaskList[0]    # ---------------------------------------------------------------------------    # internal helpers    # ---------------------------------------------------------------------------    def _readconfigfile(self, configfile):        try:            f = open(configfile, 'r')            lines = f.readlines()            self.SERVER_PATH = lines[0].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.SCRIPT_NAME = lines[1].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.SCRIPT_KEY = lines[2].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.PROJECTPATH_FN = lines[3].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.TASKPATH_FN = lines[4].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")            self.TASKREF_FN = lines[5].split(self.configsplitcharacter)[1].strip("\r\n").strip("\n")        finally:            f.close()    def _fillcmdtable(self):        self.cmdtable["printConfig"] = [self.printconfig, 0, 0, "Print configuration"]        self.cmdtable["loginUser"] = [self.loginUser, 2, 3, "No description"]        self.cmdtable["logoutUser"] = [self.logoutUser, 0, 0, "No description"]        self.cmdtable["createOperator"] = [self.createOperator, 1, 4, "No description : login, password=None, superUser='Development Team', name=None"]        self.cmdtable["removeOperator"] = [self.removeOperator, 1, 1, "No description : login"]        self.cmdtable["changePassword"] = [self.changePassword, 3, 3, "No description : login, oldPassword, password"]        self.cmdtable["getSteps"] = [self.getSteps, 0, 0, "No description"]        self.cmdtable["getShotAssets"] = [self.getShotAssets, 1, 1, "No description : shotCode"]        self.cmdtable["getSequencesInfo"] = [self.getSequencesInfo, 0, 1, "No description : sequenceCode"]        self.cmdtable["getShotInfo"] = [self.getShotInfo, 1, 1, "No description : shotCode"]        self.cmdtable["getShotsInfo"] = [self.getShotsInfo, 0, 2, "No description : shotCode, sequenceCode"]        self.cmdtable["getTasks"] = [self.getTasks, 1, 3, "No description"]    def _hash(self, password):        return hashlib.md5(password).hexdigest()    def _encodeOperator(self, operatorData):        operatorData['name'] = operatorData.pop('code')        operatorData['login'] = operatorData.pop('sg_login')        operatorData['type'] = 'Operator'        if 'sg_password' in operatorData:            operatorData.pop('sg_password')        if 'sg_company' in operatorData:            operatorData['sg_company']['type'] = "Company"        return operatorData    def _getCookiePath(self, inCreateContainer=True):        folderPath = os.path.join(os.environ["USERPROFILE"], "zombillenium", "shotgunEngine")        if inCreateContainer and not os.path.exists(folderPath):            os.makedirs(folderPath)        return os.path.join(folderPath, "auth.ini")    def _createCookie(self, login, password):        cookiePath = self._getCookiePath()        config = ConfigParser.RawConfigParser()        config.add_section('auth')        config.set('auth', 'login', login)        config.set('auth', 'password', password)        config.set('auth', 'birth', int(time.time()))        with open(cookiePath, 'w') as f:            config.write(f)    def _removeCookie(self):        cookiePath = self._getCookiePath()        if os.path.isfile(cookiePath):            os.remove(cookiePath)    def _getProjectId(self, sProjectName=None):        if sProjectName == None:            sProjectName = self.projectName        if sProjectName not in PROJECT_IDS:            raise ValueError('Given project "{}" does not exist, please choose from "{}"'                             .format(sProjectName, ','.join(PROJECT_IDS.keys())))        return PROJECT_IDS[sProjectName] if sProjectName in PROJECT_IDS else PROJECT_IDS[DEFAULT_PROJECT]    def getProjectInfo(self, sProjectName=None):        return {'type':'Project', 'id':self._getProjectId(sProjectName)}    def _getStatusList(self, sProjectName=None):        res = {}        for d in  self.sg.find("Status", [], ["code", "name"]):            res[d["code"].lower()] = d            res[d["name"].lower()] = d        return res    def getStatus(self, sStatus, sProjectName=None, fail=True):        if sProjectName and (sProjectName != self.projectName):            sgStatus = self._getStatusList(sProjectName).get(sStatus.lower())        else:            sProjectName = self.projectName            if self.__projectStatusList is None:                self.__projectStatusList = self._getStatusList()            sgStatus = self.__projectStatusList.get(sStatus.lower())        if not sgStatus and fail:            raise ValueError("Project '{}' has no such status: '{}'"                             .format(sProjectName, sStatus))        return sgStatus    def getAvailableStatuses(self, sEntityType, sFieldCode):        if (sEntityType == "Version") and (sFieldCode == "sg_status_art"):            sFieldCode = "sg_statut_art"        if sEntityType in self.__fieldSchemaData:            schemas = self.__fieldSchemaData[sEntityType]        else:            schemas = self.sg.schema_field_read(sEntityType, field_name=None,                                                project_entity=self.getProjectInfo())            self.__fieldSchemaData[sEntityType] = schemas        return schemas[sFieldCode]["properties"]["display_values"]["value"]    # ---------------------------------------------------------------------------    # Commands    # ---------------------------------------------------------------------------    # USERS    # --------------------------------    def loginUser(self, login, password=None, silent=False, hashedPassword=None, createCookie=True):        """Log a user in shotgun. It would be either a 'real' shotgun User (HumanUser) or an Operator (Shotgun type defined in constant 'OPERATOR_ENTITY')        :param login: Required, login (string) of the user to log.        :param password: Required (or hashedPassword), password (string) of the user to log.        :param silent: Optional, logging (bool)        :param hashedPassword: Required (or password), the already hashed password (string) if user is supposed to be alredy logged (with cookie)        :param createCookie: Optional, create the cookie or not (bool)        :returns: dict of the logged user if successed (with keys ['code', 'sg_login', 'id', 'sg_user']), None otherwise.        """        if password == None:            password = hashedPassword        self.currentUser = self.sg.authenticate_human_user(login, password)        if(self.currentUser != None):            if(not silent):                print "User " + login + " authenticated successfully !"        else:            if hashedPassword == None:                hashedPassword = self._hash(password)            # Ok, let's try with an Operator            filters = [                ['sg_login', 'is', login],                {                "filter_operator": "any",                "filters": [[ "sg_password", "is", ""],                            ['sg_password', 'is', hashedPassword],                            ]                }           ]            fields = USER_INFO            sgOpe = self.sg.find_one(OPERATOR_ENTITY, filters, fields)            self.currentUser = sgOpe            error = "Wrong credentials"            if self.currentUser != None:                userCurrentStep = self.currentUser['sg_currentstep']                if userCurrentStep is None:                    error = "Operator " + login + " don't have any allowed steps !! Please update shotgun..."                    self.currentUser = None                    userCurrentStepId = -1                else:                    if self.currentUser['sg_password'] == '' or self.currentUser['sg_password'] == None:                        self.currentUser['sg_password'] = hashedPassword                        self.sg.update(OPERATOR_ENTITY, self.currentUser['id'], {'sg_password':hashedPassword})                        print "Password has been updated to {0} for operator {1}".format(password, self.currentUser['sg_login'])                    userCurrentStepId = userCurrentStep['id']                    #Collect Steps entity types                    stepList = self.getSteps()                    userAllowedStepIds = tuple(d['id'] for d in self.currentUser['sg_allowedsteps'])#                    for s in self.currentUser['sg_allowedsteps']:#                        print s                    allowedSteps = []                    for step in stepList:                        stepId = step['id']                        if stepId in userAllowedStepIds:                            allowedSteps.append(step)#                            print step                        if stepId == userCurrentStepId:                            self.currentUser['sg_currentstep'] = step                    self.currentUser['sg_allowedsteps'] = allowedSteps                    self.currentUser = self._encodeOperator(self.currentUser)                    if(not silent):                        print "Operator " + login + " authenticated successfully !"        if self.currentUser == None:            raise RuntimeError('Cannot authenticate user {0} : {1}'.format(login, error))        elif createCookie:            # If we logged in successfully, create the cookie            self._createCookie(login, hashedPassword)        return self.currentUser    def getLoggedUser(self):        cookiePath = self._getCookiePath()        config = ConfigParser.RawConfigParser()        config.read(cookiePath)        if not config.has_section("auth"):            return None        # If cookie is found, verify it's still up to date        birthSeconds = int(config.get("auth", "birth"))        if time.time() - birthSeconds >= LIFETIME * 3600:            self._removeCookie()            return None        return self.loginUser(config.get("auth", "login"), hashedPassword=config.get("auth", "password"), createCookie=False)    def logoutUser(self):        self._removeCookie()        self.currentUser = None        self.sg.close()    # OPERATORS    # --------------------------------    def createOperator(self, login, password=None, superUser="Development Team", name=None):        #check if login already exists        filters = [                ['sg_login', 'is', login]           ]        fields = []        if len(login) < LOGIN_LENGTH:            print "Login too short ({0} characters minimum) !".format(LOGIN_LENGTH)            return None        if self.sg.find_one(OPERATOR_ENTITY, filters, fields) != None:            print "User with login {0} aleady exists !".format(login)            return None        if password == None:            #create random password            randStart = int(time.time() * 100.0)            password = self._hash(str(random.randint(randStart - 100, randStart + 100)))[:PASSWORD_LENGTH]        elif len(password) < PASSWORD_LENGTH:            print "Password too short ({0} characters minimum) !".format(PASSWORD_LENGTH)            return None        #verify that superUser exists and get its id        filters = [        ['name', 'is', superUser]           ]        fields = ['id']        userData = self.sg.find_one("HumanUser", filters, fields)        if userData == None:            print "Can't find superuser '{0}' !".format(superUser)            return None        if name == None:            name = login        elif len(name) < LOGIN_LENGTH:            print "Name too short ({0} characters minimum) !".format(LOGIN_LENGTH)            return None        #Ok, we're ready, create the Operator        data = {'sg_login': login,                'sg_password': self._hash(password),                'code': name,                'sg_user': userData }        result = self.sg.create(OPERATOR_ENTITY, data)        if result == None:            print "Cannot create operator !"            return None        self._encodeOperator(result)        return (result, password)    def changePassword(self, login, oldPassword, password, opId=None):        opData = {}        if opId == None:            #find the operator            filters = [                        ['sg_login', 'is', login],                        {                        "filter_operator": "any",                        "filters": [                            [ "sg_password", "is", ""],                            ['sg_password', 'is', self._hash(oldPassword)]                        ]                        }                    ]            fields = ['id']            opData = self.sg.find_one(OPERATOR_ENTITY, filters, fields)        else:            opData = {'type': OPERATOR_ENTITY, 'id': opId}        if opData != None:            data = {'sg_password': self._hash(password)}            opData = self.sg.update(OPERATOR_ENTITY, opData['id'], data)        if opData == None:            print "Cannot update operator password, login or old password incorrect !"            return False        return True    def removeOperator(self, login, opId=None):        opData = {}        if opId == None:            #find the operator            filters = [                    ['sg_login', 'is', login]               ]            fields = ['id']            opData = self.sg.find_one(OPERATOR_ENTITY, filters, fields)        else:            opData = {'type': OPERATOR_ENTITY, 'id': opId}        if opData == None:            print "Cannot remove operator '{0}', maybe it does not exists !".format(login)            return False        return self.sg.delete(OPERATOR_ENTITY, opData['id'])    # STEPS    # --------------------------------    def updateStep(self, d_inStep):        if d_inStep != self.currentUser['sg_currentstep']:            res = self.sg.update(OPERATOR_ENTITY, self.currentUser['id'], {'sg_currentstep':d_inStep})            if res:                updStep = res['sg_currentstep']                if 'name' in updStep:                    sCode = updStep.pop('name')                    updStep['code'] = sCode                self.currentUser['sg_currentstep'] = updStep    def getSteps(self):        return self.sg.find("Step", [], STEP_INFO, [{'field_name':'list_order', 'direction':'asc'}])    # ASSETS    # --------------------------------    def getShotAssets(self, in_sShotCode):        sgShot = self.sg.find_one("Shot", [["project", "is", {"type":"Project", "id":self._getProjectId()}],                                             ["code", "is", in_sShotCode]])        if sgShot:            astShotConnList = []            sAstFieldPrefix = "asset.Asset."            #We will return one occurence by default, if we want to track empty occurences we could use : ,["sg_occurences", "is_not", None]            astShotConnList = self.sg.find("AssetShotConnection", [["shot", "is", sgShot]],                                             ["shot", "sg_occurences", "asset",                                              sAstFieldPrefix + "parents",                                              sAstFieldPrefix + "sg_sous_type",                                              sAstFieldPrefix + "sg_asset_type",                                              sAstFieldPrefix + "sg_status_list"])            if not astShotConnList:                print "No assets associated to shot '{0}'".format(in_sShotCode)            else:                for astShotConn in astShotConnList:                    if astShotConn['sg_occurences'] == None:                        astShotConn['sg_occurences'] = 1                    sgAsset = astShotConn["asset"]                    for k in astShotConn.keys():                        if k.startswith(sAstFieldPrefix):                            v = astShotConn.pop(k)                            ak = k.split(sAstFieldPrefix, 1)[-1]                            sgAsset[ak] = v                    sgAsset["code"] = sgAsset["name"]            return astShotConnList        else:            print "'{0}' shot not found !".format(in_sShotCode)        return None    def getAssetInfo(self, in_sAssetCode):        return self.sg.find_one("Asset", [["project", "is", {"type":"Project", "id":self._getProjectId()}],                                          ["code", "is", in_sAssetCode]], ASSET_INFO)    def getAssetsInfo(self, in_sAssetName="", in_sCategory="", in_sSubType="",):        filters = [["project", "is", {"type":"Project", "id":self._getProjectId()}]]        if in_sAssetName != "":            filters.append(["code", "contains", in_sAssetName])        if in_sCategory != "":            filters.append(["sg_asset_type", "is", in_sCategory])        if in_sSubType != "" and ASSET_SUBTYPE_FIELD != "":            filters.append([ASSET_SUBTYPE_FIELD, "is", in_sSubType])        return self.sg.find("Asset", filters, ASSET_INFO)    # SEQUENCES    # --------------------------------    def getSequencesInfo(self, in_sSequenceCode=""):        filters = [["project", "is", {"type":"Project", "id":self._getProjectId()}]]        if in_sSequenceCode != "":            filters.append(["code", "contains", in_sSequenceCode])        sorting = [{"field_name":"code", "direction":"asc"}]        return self.sg.find("Sequence", filters, SEQUENCE_INFO, sorting)    # SHOTS    # --------------------------------    def getShotInfo(self, in_sShotCode):        return self.sg.find_one("Shot", [["project", "is", {"type":"Project", "id":self._getProjectId()}], ["code", "is", in_sShotCode]], SHOT_INFO)    def getShotsInfo(self, in_sShotCode="", in_sSequenceCode=""):        filters = [["project", "is", {"type":"Project", "id":self._getProjectId()}]]        if in_sShotCode != "":            filters.append(["code", "contains", in_sShotCode])        if in_sSequenceCode != "":            seqs = self.getSequencesInfo(in_sSequenceCode)            if len(seqs) > 0:                filterOp = {                    "filter_operator": "any",                    "filters": []                    }                for seq in seqs:                    filterOp["filters"].append(['sg_sequence', 'is', {'type':'Sequence', 'id':seq['id']}])                filters.append(filterOp)            else:                print "Can't find any sequences with pattern '{0}'".format(in_sSequenceCode)                return []        sorting = [{"field_name":"sg_cut_order", "direction":"asc"},                   {"field_name":"code", "direction":"asc"}]        return self.sg.find("Shot", filters, SHOT_INFO, sorting)    # TASKS    # --------------------------------    def getTasks(self, d_inEntity, d_inSteps=None, d_inUser=None):        filters = [                        ['entity', 'is', d_inEntity],                    ]        if d_inSteps is not None:            if isinstance(d_inSteps, (list, tuple, set)):                sgSteps = d_inSteps            else:                sgSteps = [d_inSteps]            filters.append(['step', 'in', sgSteps])        if d_inUser is not None:            filters.append([OPERATORS_FIELD, 'contains', self.context['damProject']._shotgundb.currentUser])        """        {            "filter_operator": "any",            "filters": [                [ "sg_status_list", "is", "rdy"],                [ "sg_status_list", "is", "ip" ]            ]        }        """        tasks = self.sg.find("Task", filters, TASK_INFO,                             [{'field_name':'step.Step.list_order', 'direction':'asc'},                              {'field_name':'sg_task_order', 'direction':'asc'}])        return [] if tasks is None else tasks    """    def listTasks(self, login, password, sg=None):        if(sg == None):            self.sg = Shotgun(self.SERVER_PATH, self.SCRIPT_NAME, self.SCRIPT_KEY)        else:            self.sg = sg        result = self.loginUser(login, password, self.sg)        if(result == None):            print "Incorrect login credentials !"            return        filters = [                ['task_assignees', 'is', result],                {                    "filter_operator": "any",                    "filters": [                        [ "sg_status_list", "is", "rdy"],                        [ "sg_status_list", "is", "ip" ]                    ]                }           ]        fields = ['content', 'step', 'entity', 'project', 'sg_status_list']        tasks = sg.find("Task", filters, fields)        print "Il y a " + str(len(tasks)) + " taches assignees a " + result["login"]        for task in tasks:            entityName = "NoEntity"            entityType = "NoType"            stepName = "NoStep"            if(task['entity'] != None):                entityName = task['entity']['name']                entityType = task['entity']['type']            if(task['step'] != None):                stepName = task['step']['name']            print (task['project']['name'] + " | ").ljust(25) + (entityType + " : ").ljust(10) + (stepName + " ").ljust(10) + (entityName + " - ").ljust(20) + task['content']    """    # VERIONS    # --------------------------------    def getVersions(self, d_inTask):        filters = [                   ['sg_task', 'is', d_inTask]                    ]        versions = self.sg.find("Version", filters, VERSION_INFO, [{'field_name':'code', 'direction':'asc'}])        return versions if not versions == None else []    def createVersion(self, sEntityType, s_inEntityName, s_inVersionName,                      s_inTaskName, s_inComment="", s_inSourceFile="", moreData=None):        entity = self._getEntity(s_inEntityName, s_inType=sEntityType)        if entity == None:            print "Can't get entity ({0}) from {1}".format(sEntityType, s_inEntityName)            return None        task = self._getEntity(s_inTaskName, s_inType='Task', l_customFilters=[['entity', 'is', entity]])        if task == None:            print "Can't get task {0} on {1}".format(s_inTaskName, s_inEntityName)            return None        # Create the version        versionData = {'project': {'type':'Project', 'id':self._getProjectId()},                       'code': s_inVersionName,                       'description': s_inComment,                       'entity': entity,                       'sg_task': task,                       SOURCEFILE_FIELD:s_inSourceFile                       }        if moreData:            versionData.update((k, v) for k, v in moreData.iteritems()                               if k not in versionData)        if "sg_status_art" in versionData:            versionData["sg_statut_art"] = versionData.pop("sg_status_art")        if self.currentUser and ("sg_user" in self.currentUser):            sgUser = self.currentUser["sg_user"]            if sgUser:                versionData['user'] = sgUser                updatableUser = self.currentUser.copy()                updatableUser['type'] = OPERATOR_ENTITY                versionData[OPERATOR_FIELD] = updatableUser        return self.sg.create("Version", versionData)    def uploadVersion(self, s_inVersionName, s_inMediaPath, apart=False):        version = self._getEntity(s_inVersionName, s_inType="Version")        if version:            # Use the ID from the previous result to update the newly created version calling sg.upload and specifying 'sg_uploaded_movie'            if os.path.isfile(s_inMediaPath):                bUploadDone = False                if apart:                    try:                        uploadVersionApart(version['id'], s_inMediaPath)                    except Exception as e:                        sMsg = "Could not launch the upload in an apart process:\n\n" + toStr(e)                        confirmDialog(title='SORRY !',                                      message=sMsg,                                      button=["OK"],                                      defaultButton="OK",                                      cancelButton="OK",                                      dismissString="OK",                                      icon="information")                        logMsg(sMsg, warning=True)                    else:                        bUploadDone = True                if not bUploadDone:                    logMsg("Uploading '{}'...\n          ...onto Version: '{}'."                           .format(s_inMediaPath, version["code"]))                    return self.sg.upload("Version", version['id'],                                          s_inMediaPath, "sg_uploaded_movie")            else:                print "No such media file: '{}'".format(s_inMediaPath)        else:            print "No such shotgun version: '{}'".format(s_inVersionName)        return None    def updateEntity(self, sgEntity, **data):        return self.sg.update(sgEntity["type"], sgEntity["id"], data)    def find(self, sEntityType, filters, *args, **kwargs):        return self.sg.find(sEntityType, [["project", "is", self.getProjectInfo()]] + filters,                            *args, **kwargs)    def showInBrowser(self, d_inEntity):        url = ('https://zombillenium.shotgunstudio.com/detail/{0}/{1}'               .format(d_inEntity['type'], d_inEntity['id']))        webbrowser.open(url, new=2)#2 = new tab    # ---------------------------------------------------------------------------    # cmdLine part    # ---------------------------------------------------------------------------    def printconfig(self):        print '';        print ' *** TK ShotgunEngine Config ***';        print '-----------------------------------------';        print 'SERVER_PATH "' + self.SERVER_PATH + '"'        print 'SCRIPT_NAME "' + self.SCRIPT_NAME + '"'        print 'SCRIPT_KEY "' + self.SCRIPT_KEY + '"'        print 'PROJECTPATH_FN "' + self.PROJECTPATH_FN + '"'        print 'TASKPATH_FN "' + self.TASKPATH_FN + '"'        print 'TASKREF_FN "' + self.TASKREF_FN + '"'        print '-----------------------------------------';        print '';    def printhelp(self):        print '';        print ' *** TK ShotgunEngine Help ***';        print '-----------------------------------------';        for key in self.cmdtable:            print key + " : from " + str(self.cmdtable[key][1]) + " to " + str(self.cmdtable[key][2]) + " args (" + str(self.cmdtable[key][3]) + ")"        print '-----------------------------------------';        print '';    def _parsecmdline(self, argumentsStr):        splitArgs = argumentsStr.split(" ")        arguments = []        grouping = None        for splitArg in splitArgs:            if "\"" in splitArg:                if grouping == None:                    grouping = [splitArg.replace("\"", "")]                else:                    grouping.append(splitArg.replace("\"", ""))                    arguments.append(" ".join(grouping))                    grouping = None            else:                if grouping != None:                    grouping.append(splitArg)                else:                    arguments.append(splitArg)        if grouping != None:            arguments.append(" ".join(grouping))        self._readcmdline(arguments)    def _readcmdline(self, arguments):        if len(arguments) == 0:            print "No argments given, please give at least a command name!"            self.printhelp()        else:            cmdName = arguments[0]            arguments = arguments[1:]            if cmdName in self.cmdtable:                minArgs = self.cmdtable[cmdName][1]                maxArgs = self.cmdtable[cmdName][2]                #desc = self.cmdtable[cmdName][3]                if len(arguments) >= minArgs and len(arguments) <= maxArgs :                    self._runCommand(self.cmdtable[cmdName][0], arguments)                else:                    argsHint = cmdName + " : wrong number of arguments, "                    if minArgs == maxArgs :                        argsHint += str(minArgs)                    else:                        argsHint += str(minArgs) + " to " + str(maxArgs)                    argsHint += " expected (" + str(len(arguments)) + " given)"                    print argsHint                    print "Description : {0}".format(self.cmdtable[cmdName][3])            else:                print "Command \"" + cmdName + "\" dont 'exists !"                self.printhelp()    def _runCommand(self, cb, tokens):        print cb(*tokens)if __name__ == '__main__':    core = ShotgunEngine()    if len(sys.argv) == 1:#Go into a input loop        cmdInput = ""        while True:            print ""            cmdInput = raw_input("Engine cmd >> ")            if "exit" in cmdInput.lower():                break            core._parsecmdline(cmdInput)    else:#execute command directly        core._readcmdline(sys.argv[1:])